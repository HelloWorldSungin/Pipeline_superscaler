# Pipeline_superscaler
 we have made multiple optimizations to the original pipelined MIPS processor we implemented for the first project. First, we added an L1 cache to our memory hierarchy design to decrease the average memory access time and increase the overall clocks per instruction (CPI) of our processor. Next we made optimizations that exploit instruction-level parallelism (ILP) to increase the efficiency of our pipeline and maximize the utilization of all the hardware components of the processor. In project 3 we added a dynamic branch predictor to our design to prevent the need for flushing previously fetched instructions based on the outcome of a conditional branch instruction. Now for project 4 we are changing the design of our MIPS processor to issue/process 2 instructions every clock cycle instead of just 1. Ideally, this optimization would double the processor's  instructions per cycle (IPC), but in reality it also creates a number of new hazards that require new stalling and scheduling logic.
Multiple-issue superscalar processors are characterized by the order in which they execute instructions and the method used to schedule these instructions. Static (in-order) and dynamic (out-of-order). Simply, static superscalar executes instructions in program order, and dynamic super allows out-of-order program execution either can be programmed on software in compile time or implemented on hardware using instruction buffer/window in the decode state to reorder the program to gain maximum performance. Both implementation requires a great detail of in resolving hazards because of the possible data dependencies between two concurrent instructions. However, dynamic scheduling is definitely more difficult to implement than static scheduling. It requires complicated control logic such as Tomasulo algorithm to gain the debatably the better performance by rearranging the instruction execuations. Both static and dynamic scheduling fulfill the instruction level parallelism (ILP) which is the measure of the average number of instructions that processor is capable of executing at the same time.
In this project, we will be implementing static in-order scheduling superscalar dual-issue processor. On top of the new superscalar processor, we will be also adding on the cache memory and branch predictor that we implemented in the previous projects.
